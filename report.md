# Report 1

20302010043 苏佳迪

### 项目信息

##### 项目目录

项目源码列在`src`下，目录如下：

```text
src
|--- config.js	（配置数据）
|--- sc.js		（扫描转换算法实现）
|--- scanConversion.html	（页面）
```

##### 开发与运行环境

浏览器：最新版本Google Chrome。

##### 运行及使用方法

用浏览器打开`scanConversion.html`文件即可。

### 项目中的亮点

##### 1、多边形扫描转换算法

扫描转换算法中采用活性边的结构，避免了扫描线与多边形求交的过程，大大降低复杂度；同时省去了需要判断交点奇偶的逻辑，简化了代码实现。

**活性边表（AET）**

活性边是指当前与扫描线相交的多边形的边，活性边表包括了当前所有的活性边，为每条活性边维护了一个如下的表项：

```javascript
let entry = {
    x : 0,				// 当前扫描线与活性边交点的x坐标
    delta : 0,			// 活性边斜率倒数，即每次移动扫描线时x坐标的改变量（避免求交运算）
    y_max : 0			// 活性边最大的y坐标（扫描线到该处之后需要把活性边从AET中去掉）
};
```

活性边表是一个由`entry`组成的链表，有了该数据结构后，可以实现不需要求交而得到交点。扫描线每次移动后，读`entry.x`得到上次的交点坐标，加上delta后得到此次扫描交点。对每个活性边项做此过程，得到交点后按上面扫描线算法的思路进行绘制四边形。

**新边表（NET）**

新边表结构用于完成活性边表项的添加，在扫描开始前，读取四个顶点并生成新边表。新边表是一个数组，数组的长度是四边形的y方向跨域长度，且每个表项对应一个y坐标的扫描线（即net[0]的表项对应y<sub>min</sub>扫描线，net[1]的表项对应y<sub>min</sub> + 1扫描线）。

新边表的表项是一个链表，将新加入的活性边边信息链接起来，每个结点结构如下：

```js
let entry = {
    y_max : 0,			// 活性边最大的y坐标（扫描线到该处之后需要把活性边从AET中去掉）
    x_start : 0,		// 活性边加入时的起始x坐标
    delta : 0			// 活性边斜率倒数，即每次移动扫描线时x坐标的改变量（避免求交运算）
}
```

**实现逻辑**

有上述数据结构后，绘制一个四边形的过程如下：

- 读取四个顶点的坐标，确定四条线的delta，并生成新边表NET；
- 从y<sub>min</sub>开始扫描，每次扫描先判断是否有要加进来的活性边，然后读取活性边表得到一系列x坐标；
- 将坐标按序两两分组，用`drawLine()`画线；
- 画线完成后，若活性边需要去除则从表中删除；

##### 2、对顶点圆形的填充

避免使用用`fill()`函数填充圆形顶点的内部部分，在绘制圆形顶点内部红色时，对角度从0到Π / 2遍历，利用对称性画出四个象限中圆形到圆周的直线（调用`drawLine()`）。

### 开发中遇到的问题

主要问题是图形的绘制顺序，通过观察`sample`的效果，发现在拖拽一个顶点覆盖住另一个顶点时，永远是被拖拽的四边形在上，不动的四边形在下。为了实现这个效果，首先尝试是只对被拖动顶点涉及到的四边形重新绘制，但由于覆盖后再移开时原位置颜色难以控制，以失败告终。

目前通过调整四个多边形绘制的顺序，保证被移动顶点涉及的四边形总是在未涉及到的四边形之后绘制，从而达到覆盖住的效果。

### 项目仍存在的缺陷

##### 1、判断鼠标按下时是否选中顶点

由于要考虑容差，判断鼠标是否选中顶点时需要经过相对复杂的逻辑如下：

```js
if (offsetX >= x - range && offsetX <= x + range && offsetY >= y - range && offsetY <= y + range) {
    // ...
}
```

且这里需要对九个顶点遍历，相对来说较慢。个人感觉可以设计一种数据结构，不需要循环遍历顶点便可以得到选中的顶点下标。

##### 2、拖拽时的重新绘制

目前拖拽顶点时，无论是否相关，四个多边形都会被重新绘制，造成了不必要的重新绘制。个人感觉有算法能够在只重新绘制被影响的四边形（如与被拖拽的顶点相关，或者拖拽过程中被覆盖）。

