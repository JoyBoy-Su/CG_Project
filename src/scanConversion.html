<!DOCTYPE HTML>
<html>
<head>
    <title>CG project1 - part1</title>
    <script src="./config.js"></script>
    <script src="./sc.js"></script>
    <script>
        var move = false;       // 鼠标是否按住移动
        var move_index = -1;    // 移动的端点下标
        // TODO：维护一个可以直接由(x, y)计算得到move_index的数据结构
        const order = [
            [1, 2, 3, 0], [2, 3, 0, 1], [0, 2, 3, 1],
            [1, 3, 0, 2], [0, 1, 2, 3], [0, 2, 1, 3], 
            [0, 1, 3, 2], [0, 1, 2, 3], [0, 1, 2, 3]
        ];
    </script>
</head>
<body>
    <canvas id="myCanvas" width="1024" height="768" style="border:1px solid #c3c3c3;">
    Your browser does not support the canvas element.
    </canvas>
    <script type="text/javascript">

        // mouse按下
        function canvasMouseDown(event) {
            // 检查是否选中某个vertex，并标记vertex为对应序号
            for (var i = 0; i < vertex_pos.length; i++) {
                vertex = vertex_pos[i];
                // console.log("vertex ", i , " = ", vertex);
                if ((event.offsetX >= vertex[0] - range) && (event.offsetX <= vertex[0] + range)
                && (event.offsetY >= vertex[1] - range) && (event.offsetY <= vertex[1] + range)) {
                    move_index = i;
                    move = true;
                    break;
                }
            }
        }

        // mouse移动
        function canvasMouseMove(event) {
            // 若move被标记，执行移动操作，并通过vertex确定移动的顶点
            if (move === true && move_index >= 0) {
                // TODO：设置一定的响应范围，移动超过多少个像素才绘制
                vertex = vertex_pos[move_index];
                vertex[0] = event.offsetX;
                vertex[1] = event.offsetY;
                let _polygon = [];
                for (let i = 0; i < order[move_index].length; i++) {
                    _polygon[i] = polygon[order[move_index][i]];
                }
                // console.log("_polygon: ", _polygon);
                let _color = [];
                for (let i = 0; i < order[move_index].length; i++) {
                    _color[i] = vertex_color[color_map[order[move_index][i]]];
                }
                // console.log("_color: ", _color);
                // clear
                var cxt = document.getElementById("myCanvas").getContext("2d");
                cxt.clearRect(-1, -1, canvas_obj.width, canvas_obj.height);
                drawCanvas(cxt, vertex_pos, _polygon, _color);
            }
        }

        // mouse松开
        function canvasMouseUp(event) {
            move = false;
            move_index = -1;
        }

        // canvas逻辑
        var canvas_obj = document.getElementById("myCanvas");
        // 绑定鼠标事件
        canvas_obj.onmousedown = canvasMouseDown;
        canvas_obj.onmousemove = canvasMouseMove;
        canvas_obj.onmouseup = canvasMouseUp;

        var cxt = canvas_obj.getContext("2d");
		
		//将canvas坐标整体偏移0.5，用于解决宽度为1个像素的线段的绘制问题，具体原理详见project文档
		cxt.translate(0.5, 0.5);
        let _color = [vertex_color[color_map[0]], vertex_color[color_map[1]], 
            vertex_color[color_map[2]], vertex_color[color_map[3]]];
        drawCanvas(cxt, vertex_pos, polygon, _color);

    </script>
 
</body>
</html>